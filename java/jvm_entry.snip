*) project configure command:
    bash ./configure --with-boot-jdk=/home/hi/Binary/boot-jdk/jdk-13

all in src/java.base/share/native/libjli/java.c --> JavaMain(...)
*) main invoke process
    src/java.base/share/native/launcher/main.c 
        --> main(int argc, char **argv)
        src/java.base/share/native/libjli/java.c:
            --> JLI_Launch(...)
            src/java.base/unix/native/libjli/java_md_solinux.c
                <<<<  --> LoadJavaVM(...) init jvm create hook is in this method  >>>>
                --> JVMInit(...)
                src/java.base/share/native/libjli/java.c
                    --> ContinueInNewThread(...)
                    src/java.base/unix/native/libjli/java_md_solinux.c
                        --> CallJavaMainInNewThread(...)
                            if (pthread_create(&tid, &attr, ThreadJavaMain, args) == 0)
                            ThreadJavaMain() --> return (void*)(intptr_t)JavaMain(args);
                        src/java.base/share/native/libjli/java.c
                            --> JavaMain(void* _args)
                                <<<<  --> InitializeJVM(...) initialize jvm logical is here >>>> 
                                --> (*env)->CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
                            src/hotspot/share/prims/jni.cpp
                                --> CallStaticVoidMethod(...)
                                    --> jni_invoke_static(...)
                                        --> JavaCalls::call(result, method, &java_args, CHECK);
                                src/hotspot/share/runtime/javaCalls.cpp
                                    -->call(...)
                                        --> void JavaCalls::call_helper(...)
                                            --> StubRoutines::call_stub()(...) #call_stub return CallStub pointer
                                    src/hotspot/share/runtime/stubRoutines.hpp
                                        --> static CallStub call_stub() { return CAST_TO_FN_PTR(CallStub, _call_stub_entry); }
                                            --> #define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast<func_type>(value))
                                                ## _call_stub_entry is a CallStub pointer
    

*) _call_stub_entry info:
    defined in :
    src/hotspot/share/runtime/stubRoutines.hpp
        --> class StubRoutines: AllStatic
              static address _call_stub_entry;


*) _call_stub_entry is initialized in jvm init process, jvm initial process is process as below:
    init jvm func in :
        src/java.base/share/native/libjli/java.c
        --> JLI_Launch(...)
        -->     if (!LoadJavaVM(jvmpath, &ifn))
            src/java.base/unix/native/libjli/java_md_solinux.c
            --> LoadJavaVM(...)
            --> ifn->CreateJavaVM = (CreateJavaVM_t) dlsym(libjvm, "JNI_CreateJavaVM");
    
    call init jvm func in :
        src/java.base/share/native/libjli/java.c
            --> JavaMain(void* _args)
                src/hotspot/share/prims/jni.cpp
                --> _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args)
                    --> static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args)
                    --> result = Threads::create_vm((JavaVMInitArgs*) args, &can_try_again);
                    src/hotspot/share/runtime/thread.cpp
                        --> jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain)
                            --> jint status = init_globals();
                                src/hotspot/share/runtime/init.cpp
                                --> init_globals()
                                --> stubRoutines_init1 OR 2
                                src/hotspot/share/runtime/stubRoutines.cpp
                                    --> stubRoutines_init1 OR 2
                                        --> address StubRoutines::_call_stub_entry = NULL;
                                        --> StubRoutines::initialize1()  OR StubRoutines::initialize2() 
                                            src/hotspot/cpu/x86/stubGenerator_x86_64.cpp
                                                --> StubGenerator_generate(CodeBuffer* code, bool all)
                                                    -->   void generate_initial()
                                                        StubRoutines::_call_stub_entry = generate_call_stub(StubRoutines::_call_stub_return_address);
                                                        --> address generate_call_stub(address& return_address) {...asm code...}

*) Thread relevant defintion in
    src/hotspot/share/runtime/thread.hpp && src/hotspot/share/runtime/thread.cpp

*) Mememory initialize 
    src/hotspot/share/runtime/thread.cpp
        --> jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain)
            -->  vm_init_globals();
                --> src/hotspot/share/runtime/init.cpp
                    void vm_init_globals() {
                        ......
                        chunkpool_init(); --> Mememory Initialize
                        ......
                    }

*) TLS (Thread Local Storage 相关的) 
    src/hotspot/os/posix/threadLocalStorage_posix.cpp
    void ThreadLocalStorage::init();
        使用的是pthreade_key相关特性实现的:
            int rslt = pthread_key_create(&_thread_key, restore_thread_pointer);
            void ThreadLocalStorage::set_thread(Thread* current), 会把当前线程的Thread结构数据保存在TLS中
            Thread* ThreadLocalStorage::thread(), 会取出当前线程保存在TLS中的信息

*)  ostream_init(); 的初始化过程
    src/hotspot/share/utilities/ostream.cpp --> ostream_init() {...}
        src/hotspot/share/utilities/defaultStream.hpp
            src/hotspot/share/utilities/xmlstream.hpp
                src/hotspot/share/utilities/ostream.hpp
        //具体的初始化语句: 这里的new操作符被rewrite了
        defaultStream::instance = new(ResourceObj::C_HEAP, mtInternal) defaultStream();
            //new 操作符rewrite的位置在父类 class ResourceObj ALLOCATION_SUPER_CLASS_SPEC  中
            //位置: src/hotspot/share/memory/allocation.hpp 
             public:
                void* operator new(size_t size, allocation_type type, MEMFLAGS flags) throw();
                void* operator new [](size_t size, allocation_type type, MEMFLAGS flags) throw();
                void* operator new(size_t size, const std::nothrow_t&  nothrow_constant,
                    allocation_type type, MEMFLAGS flags) throw();
                void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant,
                    allocation_type type, MEMFLAGS flags) throw();
                ......
                    src/hotspot/share/memory/allocation.hpp
                        #define METASPACE_OBJ_TYPES_DO(f) \ 定义了 mtInternal 枚举 mtInternal means "memory type internal"
                        通常引用方式: typedef MemoryType MEMFLAGS;
            
            new(ResourceObj::C_HEAP, mtInternal) 的实现在ResourceObj类 : src/hotspot/share/memory/allocation.cpp
                具体方法 --> void* ResourceObj::operator new(size_t size, allocation_type type, MEMFLAGS flags) throw() {
                其中的size_t size类似new 重载的系统参数，调用的时候可以忽略
                分配的方式分为C_HEAP(调用malloc分配) 和 RESOURCE_AREA分配 (jvm 的堆上分配)

            "technically UB" means "Undefined Behaviour" always means Bug.
            文件: src/hotspot/share/utilities/ostream.cpp 是对标准输入输出的基本实现，是熟悉的c代码了

*) os::init();
    src/hotspot/os/linux/os_linux.cpp

*) 全局配置的存储位置: /share/runtime/globals.hpp
    diagnostic(bool, LogVMOutput, false, "Save VM output to LogFile")

*) Jvmti mean "jvm tool interface": 可以写jvm相关的外挂程序，相当与plugin或者nginx的module的机制
      JvmtiExport::enter_onload_phase();

